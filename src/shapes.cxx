// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "shapes.hxx"

// delta_tType
// 

const delta_tType::t_optional& delta_tType::
t () const
{
  return this->t_;
}

delta_tType::t_optional& delta_tType::
t ()
{
  return this->t_;
}

void delta_tType::
t (const t_type& x)
{
  this->t_.set (x);
}

void delta_tType::
t (const t_optional& x)
{
  this->t_ = x;
}

void delta_tType::
t (::std::unique_ptr< t_type > x)
{
  this->t_.set (std::move (x));
}


// end_timeType
// 

const end_timeType::t_optional& end_timeType::
t () const
{
  return this->t_;
}

end_timeType::t_optional& end_timeType::
t ()
{
  return this->t_;
}

void end_timeType::
t (const t_type& x)
{
  this->t_.set (x);
}

void end_timeType::
t (const t_optional& x)
{
  this->t_ = x;
}

void end_timeType::
t (::std::unique_ptr< t_type > x)
{
  this->t_.set (std::move (x));
}


// factorType
// 

const factorType::val_optional& factorType::
val () const
{
  return this->val_;
}

factorType::val_optional& factorType::
val ()
{
  return this->val_;
}

void factorType::
val (const val_type& x)
{
  this->val_.set (x);
}

void factorType::
val (const val_optional& x)
{
  this->val_ = x;
}

void factorType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// domain_sizeType
// 

const domain_sizeType::x_optional& domain_sizeType::
x () const
{
  return this->x_;
}

domain_sizeType::x_optional& domain_sizeType::
x ()
{
  return this->x_;
}

void domain_sizeType::
x (const x_type& x)
{
  this->x_.set (x);
}

void domain_sizeType::
x (const x_optional& x)
{
  this->x_ = x;
}

void domain_sizeType::
x (::std::unique_ptr< x_type > x)
{
  this->x_.set (std::move (x));
}

const domain_sizeType::y_optional& domain_sizeType::
y () const
{
  return this->y_;
}

domain_sizeType::y_optional& domain_sizeType::
y ()
{
  return this->y_;
}

void domain_sizeType::
y (const y_type& x)
{
  this->y_.set (x);
}

void domain_sizeType::
y (const y_optional& x)
{
  this->y_ = x;
}

void domain_sizeType::
y (::std::unique_ptr< y_type > x)
{
  this->y_.set (std::move (x));
}

const domain_sizeType::z_optional& domain_sizeType::
z () const
{
  return this->z_;
}

domain_sizeType::z_optional& domain_sizeType::
z ()
{
  return this->z_;
}

void domain_sizeType::
z (const z_type& x)
{
  this->z_.set (x);
}

void domain_sizeType::
z (const z_optional& x)
{
  this->z_ = x;
}

void domain_sizeType::
z (::std::unique_ptr< z_type > x)
{
  this->z_.set (std::move (x));
}


// rcutoffType
// 

const rcutoffType::val_optional& rcutoffType::
val () const
{
  return this->val_;
}

rcutoffType::val_optional& rcutoffType::
val ()
{
  return this->val_;
}

void rcutoffType::
val (const val_type& x)
{
  this->val_.set (x);
}

void rcutoffType::
val (const val_optional& x)
{
  this->val_ = x;
}

void rcutoffType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// x1_boundary_conditionType
// 

const x1_boundary_conditionType::val_optional& x1_boundary_conditionType::
val () const
{
  return this->val_;
}

x1_boundary_conditionType::val_optional& x1_boundary_conditionType::
val ()
{
  return this->val_;
}

void x1_boundary_conditionType::
val (const val_type& x)
{
  this->val_.set (x);
}

void x1_boundary_conditionType::
val (const val_optional& x)
{
  this->val_ = x;
}

void x1_boundary_conditionType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// x2_boundary_conditionType
// 

const x2_boundary_conditionType::val_optional& x2_boundary_conditionType::
val () const
{
  return this->val_;
}

x2_boundary_conditionType::val_optional& x2_boundary_conditionType::
val ()
{
  return this->val_;
}

void x2_boundary_conditionType::
val (const val_type& x)
{
  this->val_.set (x);
}

void x2_boundary_conditionType::
val (const val_optional& x)
{
  this->val_ = x;
}

void x2_boundary_conditionType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// y1_boundary_conditionType
// 

const y1_boundary_conditionType::val_optional& y1_boundary_conditionType::
val () const
{
  return this->val_;
}

y1_boundary_conditionType::val_optional& y1_boundary_conditionType::
val ()
{
  return this->val_;
}

void y1_boundary_conditionType::
val (const val_type& x)
{
  this->val_.set (x);
}

void y1_boundary_conditionType::
val (const val_optional& x)
{
  this->val_ = x;
}

void y1_boundary_conditionType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// y2_boundary_conditionType
// 

const y2_boundary_conditionType::val_optional& y2_boundary_conditionType::
val () const
{
  return this->val_;
}

y2_boundary_conditionType::val_optional& y2_boundary_conditionType::
val ()
{
  return this->val_;
}

void y2_boundary_conditionType::
val (const val_type& x)
{
  this->val_.set (x);
}

void y2_boundary_conditionType::
val (const val_optional& x)
{
  this->val_ = x;
}

void y2_boundary_conditionType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// z1_boundary_conditionType
// 

const z1_boundary_conditionType::val_optional& z1_boundary_conditionType::
val () const
{
  return this->val_;
}

z1_boundary_conditionType::val_optional& z1_boundary_conditionType::
val ()
{
  return this->val_;
}

void z1_boundary_conditionType::
val (const val_type& x)
{
  this->val_.set (x);
}

void z1_boundary_conditionType::
val (const val_optional& x)
{
  this->val_ = x;
}

void z1_boundary_conditionType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// z2_boundary_conditionType
// 

const z2_boundary_conditionType::val_optional& z2_boundary_conditionType::
val () const
{
  return this->val_;
}

z2_boundary_conditionType::val_optional& z2_boundary_conditionType::
val ()
{
  return this->val_;
}

void z2_boundary_conditionType::
val (const val_type& x)
{
  this->val_.set (x);
}

void z2_boundary_conditionType::
val (const val_optional& x)
{
  this->val_ = x;
}

void z2_boundary_conditionType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// brownian_motionType
// 

const brownian_motionType::bol_optional& brownian_motionType::
bol () const
{
  return this->bol_;
}

brownian_motionType::bol_optional& brownian_motionType::
bol ()
{
  return this->bol_;
}

void brownian_motionType::
bol (const bol_type& x)
{
  this->bol_.set (x);
}

void brownian_motionType::
bol (const bol_optional& x)
{
  this->bol_ = x;
}

void brownian_motionType::
bol (::std::unique_ptr< bol_type > x)
{
  this->bol_.set (std::move (x));
}


// initial_temperatureType
// 

const initial_temperatureType::val_optional& initial_temperatureType::
val () const
{
  return this->val_;
}

initial_temperatureType::val_optional& initial_temperatureType::
val ()
{
  return this->val_;
}

void initial_temperatureType::
val (const val_type& x)
{
  this->val_.set (x);
}

void initial_temperatureType::
val (const val_optional& x)
{
  this->val_ = x;
}

void initial_temperatureType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// n_thermostatType
// 

const n_thermostatType::t_optional& n_thermostatType::
t () const
{
  return this->t_;
}

n_thermostatType::t_optional& n_thermostatType::
t ()
{
  return this->t_;
}

void n_thermostatType::
t (const t_type& x)
{
  this->t_.set (x);
}

void n_thermostatType::
t (const t_optional& x)
{
  this->t_ = x;
}

void n_thermostatType::
t (::std::unique_ptr< t_type > x)
{
  this->t_.set (std::move (x));
}


// target_temperatureType
// 

const target_temperatureType::val_optional& target_temperatureType::
val () const
{
  return this->val_;
}

target_temperatureType::val_optional& target_temperatureType::
val ()
{
  return this->val_;
}

void target_temperatureType::
val (const val_type& x)
{
  this->val_.set (x);
}

void target_temperatureType::
val (const val_optional& x)
{
  this->val_ = x;
}

void target_temperatureType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// temperature_differenceType
// 

const temperature_differenceType::val_optional& temperature_differenceType::
val () const
{
  return this->val_;
}

temperature_differenceType::val_optional& temperature_differenceType::
val ()
{
  return this->val_;
}

void temperature_differenceType::
val (const val_type& x)
{
  this->val_.set (x);
}

void temperature_differenceType::
val (const val_optional& x)
{
  this->val_ = x;
}

void temperature_differenceType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// gravitationType
// 

const gravitationType::val_optional& gravitationType::
val () const
{
  return this->val_;
}

gravitationType::val_optional& gravitationType::
val ()
{
  return this->val_;
}

void gravitationType::
val (const val_type& x)
{
  this->val_.set (x);
}

void gravitationType::
val (const val_optional& x)
{
  this->val_ = x;
}

void gravitationType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// r0Type
// 

const r0Type::val_optional& r0Type::
val () const
{
  return this->val_;
}

r0Type::val_optional& r0Type::
val ()
{
  return this->val_;
}

void r0Type::
val (const val_type& x)
{
  this->val_.set (x);
}

void r0Type::
val (const val_optional& x)
{
  this->val_ = x;
}

void r0Type::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// kType
// 

const kType::val_optional& kType::
val () const
{
  return this->val_;
}

kType::val_optional& kType::
val ()
{
  return this->val_;
}

void kType::
val (const val_type& x)
{
  this->val_.set (x);
}

void kType::
val (const val_optional& x)
{
  this->val_ = x;
}

void kType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// fz_upType
// 

const fz_upType::val_optional& fz_upType::
val () const
{
  return this->val_;
}

fz_upType::val_optional& fz_upType::
val ()
{
  return this->val_;
}

void fz_upType::
val (const val_type& x)
{
  this->val_.set (x);
}

void fz_upType::
val (const val_optional& x)
{
  this->val_ = x;
}

void fz_upType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// parallelisation_methodType
// 

const parallelisation_methodType::val_optional& parallelisation_methodType::
val () const
{
  return this->val_;
}

parallelisation_methodType::val_optional& parallelisation_methodType::
val ()
{
  return this->val_;
}

void parallelisation_methodType::
val (const val_type& x)
{
  this->val_.set (x);
}

void parallelisation_methodType::
val (const val_optional& x)
{
  this->val_ = x;
}

void parallelisation_methodType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// force_calculation_methodType
// 

const force_calculation_methodType::val_optional& force_calculation_methodType::
val () const
{
  return this->val_;
}

force_calculation_methodType::val_optional& force_calculation_methodType::
val ()
{
  return this->val_;
}

void force_calculation_methodType::
val (const val_type& x)
{
  this->val_.set (x);
}

void force_calculation_methodType::
val (const val_optional& x)
{
  this->val_ = x;
}

void force_calculation_methodType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// rlType
// 

const rlType::val_optional& rlType::
val () const
{
  return this->val_;
}

rlType::val_optional& rlType::
val ()
{
  return this->val_;
}

void rlType::
val (const val_type& x)
{
  this->val_.set (x);
}

void rlType::
val (const val_optional& x)
{
  this->val_ = x;
}

void rlType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// settingsType
// 

const settingsType::delta_t_type& settingsType::
delta_t () const
{
  return this->delta_t_.get ();
}

settingsType::delta_t_type& settingsType::
delta_t ()
{
  return this->delta_t_.get ();
}

void settingsType::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

void settingsType::
delta_t (::std::unique_ptr< delta_t_type > x)
{
  this->delta_t_.set (std::move (x));
}

const settingsType::end_time_type& settingsType::
end_time () const
{
  return this->end_time_.get ();
}

settingsType::end_time_type& settingsType::
end_time ()
{
  return this->end_time_.get ();
}

void settingsType::
end_time (const end_time_type& x)
{
  this->end_time_.set (x);
}

void settingsType::
end_time (::std::unique_ptr< end_time_type > x)
{
  this->end_time_.set (std::move (x));
}

const settingsType::factor_type& settingsType::
factor () const
{
  return this->factor_.get ();
}

settingsType::factor_type& settingsType::
factor ()
{
  return this->factor_.get ();
}

void settingsType::
factor (const factor_type& x)
{
  this->factor_.set (x);
}

void settingsType::
factor (::std::unique_ptr< factor_type > x)
{
  this->factor_.set (std::move (x));
}

const settingsType::domain_size_type& settingsType::
domain_size () const
{
  return this->domain_size_.get ();
}

settingsType::domain_size_type& settingsType::
domain_size ()
{
  return this->domain_size_.get ();
}

void settingsType::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void settingsType::
domain_size (::std::unique_ptr< domain_size_type > x)
{
  this->domain_size_.set (std::move (x));
}

const settingsType::rcutoff_type& settingsType::
rcutoff () const
{
  return this->rcutoff_.get ();
}

settingsType::rcutoff_type& settingsType::
rcutoff ()
{
  return this->rcutoff_.get ();
}

void settingsType::
rcutoff (const rcutoff_type& x)
{
  this->rcutoff_.set (x);
}

void settingsType::
rcutoff (::std::unique_ptr< rcutoff_type > x)
{
  this->rcutoff_.set (std::move (x));
}

const settingsType::x1_boundary_condition_type& settingsType::
x1_boundary_condition () const
{
  return this->x1_boundary_condition_.get ();
}

settingsType::x1_boundary_condition_type& settingsType::
x1_boundary_condition ()
{
  return this->x1_boundary_condition_.get ();
}

void settingsType::
x1_boundary_condition (const x1_boundary_condition_type& x)
{
  this->x1_boundary_condition_.set (x);
}

void settingsType::
x1_boundary_condition (::std::unique_ptr< x1_boundary_condition_type > x)
{
  this->x1_boundary_condition_.set (std::move (x));
}

const settingsType::x2_boundary_condition_type& settingsType::
x2_boundary_condition () const
{
  return this->x2_boundary_condition_.get ();
}

settingsType::x2_boundary_condition_type& settingsType::
x2_boundary_condition ()
{
  return this->x2_boundary_condition_.get ();
}

void settingsType::
x2_boundary_condition (const x2_boundary_condition_type& x)
{
  this->x2_boundary_condition_.set (x);
}

void settingsType::
x2_boundary_condition (::std::unique_ptr< x2_boundary_condition_type > x)
{
  this->x2_boundary_condition_.set (std::move (x));
}

const settingsType::y1_boundary_condition_type& settingsType::
y1_boundary_condition () const
{
  return this->y1_boundary_condition_.get ();
}

settingsType::y1_boundary_condition_type& settingsType::
y1_boundary_condition ()
{
  return this->y1_boundary_condition_.get ();
}

void settingsType::
y1_boundary_condition (const y1_boundary_condition_type& x)
{
  this->y1_boundary_condition_.set (x);
}

void settingsType::
y1_boundary_condition (::std::unique_ptr< y1_boundary_condition_type > x)
{
  this->y1_boundary_condition_.set (std::move (x));
}

const settingsType::y2_boundary_condition_type& settingsType::
y2_boundary_condition () const
{
  return this->y2_boundary_condition_.get ();
}

settingsType::y2_boundary_condition_type& settingsType::
y2_boundary_condition ()
{
  return this->y2_boundary_condition_.get ();
}

void settingsType::
y2_boundary_condition (const y2_boundary_condition_type& x)
{
  this->y2_boundary_condition_.set (x);
}

void settingsType::
y2_boundary_condition (::std::unique_ptr< y2_boundary_condition_type > x)
{
  this->y2_boundary_condition_.set (std::move (x));
}

const settingsType::z1_boundary_condition_type& settingsType::
z1_boundary_condition () const
{
  return this->z1_boundary_condition_.get ();
}

settingsType::z1_boundary_condition_type& settingsType::
z1_boundary_condition ()
{
  return this->z1_boundary_condition_.get ();
}

void settingsType::
z1_boundary_condition (const z1_boundary_condition_type& x)
{
  this->z1_boundary_condition_.set (x);
}

void settingsType::
z1_boundary_condition (::std::unique_ptr< z1_boundary_condition_type > x)
{
  this->z1_boundary_condition_.set (std::move (x));
}

const settingsType::z2_boundary_condition_type& settingsType::
z2_boundary_condition () const
{
  return this->z2_boundary_condition_.get ();
}

settingsType::z2_boundary_condition_type& settingsType::
z2_boundary_condition ()
{
  return this->z2_boundary_condition_.get ();
}

void settingsType::
z2_boundary_condition (const z2_boundary_condition_type& x)
{
  this->z2_boundary_condition_.set (x);
}

void settingsType::
z2_boundary_condition (::std::unique_ptr< z2_boundary_condition_type > x)
{
  this->z2_boundary_condition_.set (std::move (x));
}

const settingsType::brownian_motion_type& settingsType::
brownian_motion () const
{
  return this->brownian_motion_.get ();
}

settingsType::brownian_motion_type& settingsType::
brownian_motion ()
{
  return this->brownian_motion_.get ();
}

void settingsType::
brownian_motion (const brownian_motion_type& x)
{
  this->brownian_motion_.set (x);
}

void settingsType::
brownian_motion (::std::unique_ptr< brownian_motion_type > x)
{
  this->brownian_motion_.set (std::move (x));
}

const settingsType::initial_temperature_type& settingsType::
initial_temperature () const
{
  return this->initial_temperature_.get ();
}

settingsType::initial_temperature_type& settingsType::
initial_temperature ()
{
  return this->initial_temperature_.get ();
}

void settingsType::
initial_temperature (const initial_temperature_type& x)
{
  this->initial_temperature_.set (x);
}

void settingsType::
initial_temperature (::std::unique_ptr< initial_temperature_type > x)
{
  this->initial_temperature_.set (std::move (x));
}

const settingsType::n_thermostat_type& settingsType::
n_thermostat () const
{
  return this->n_thermostat_.get ();
}

settingsType::n_thermostat_type& settingsType::
n_thermostat ()
{
  return this->n_thermostat_.get ();
}

void settingsType::
n_thermostat (const n_thermostat_type& x)
{
  this->n_thermostat_.set (x);
}

void settingsType::
n_thermostat (::std::unique_ptr< n_thermostat_type > x)
{
  this->n_thermostat_.set (std::move (x));
}

const settingsType::target_temperature_type& settingsType::
target_temperature () const
{
  return this->target_temperature_.get ();
}

settingsType::target_temperature_type& settingsType::
target_temperature ()
{
  return this->target_temperature_.get ();
}

void settingsType::
target_temperature (const target_temperature_type& x)
{
  this->target_temperature_.set (x);
}

void settingsType::
target_temperature (::std::unique_ptr< target_temperature_type > x)
{
  this->target_temperature_.set (std::move (x));
}

const settingsType::temperature_difference_type& settingsType::
temperature_difference () const
{
  return this->temperature_difference_.get ();
}

settingsType::temperature_difference_type& settingsType::
temperature_difference ()
{
  return this->temperature_difference_.get ();
}

void settingsType::
temperature_difference (const temperature_difference_type& x)
{
  this->temperature_difference_.set (x);
}

void settingsType::
temperature_difference (::std::unique_ptr< temperature_difference_type > x)
{
  this->temperature_difference_.set (std::move (x));
}

const settingsType::gravitation_type& settingsType::
gravitation () const
{
  return this->gravitation_.get ();
}

settingsType::gravitation_type& settingsType::
gravitation ()
{
  return this->gravitation_.get ();
}

void settingsType::
gravitation (const gravitation_type& x)
{
  this->gravitation_.set (x);
}

void settingsType::
gravitation (::std::unique_ptr< gravitation_type > x)
{
  this->gravitation_.set (std::move (x));
}

const settingsType::r0_type& settingsType::
r0 () const
{
  return this->r0_.get ();
}

settingsType::r0_type& settingsType::
r0 ()
{
  return this->r0_.get ();
}

void settingsType::
r0 (const r0_type& x)
{
  this->r0_.set (x);
}

void settingsType::
r0 (::std::unique_ptr< r0_type > x)
{
  this->r0_.set (std::move (x));
}

const settingsType::k_type& settingsType::
k () const
{
  return this->k_.get ();
}

settingsType::k_type& settingsType::
k ()
{
  return this->k_.get ();
}

void settingsType::
k (const k_type& x)
{
  this->k_.set (x);
}

void settingsType::
k (::std::unique_ptr< k_type > x)
{
  this->k_.set (std::move (x));
}

const settingsType::fz_up_type& settingsType::
fz_up () const
{
  return this->fz_up_.get ();
}

settingsType::fz_up_type& settingsType::
fz_up ()
{
  return this->fz_up_.get ();
}

void settingsType::
fz_up (const fz_up_type& x)
{
  this->fz_up_.set (x);
}

void settingsType::
fz_up (::std::unique_ptr< fz_up_type > x)
{
  this->fz_up_.set (std::move (x));
}

const settingsType::parallelisation_method_type& settingsType::
parallelisation_method () const
{
  return this->parallelisation_method_.get ();
}

settingsType::parallelisation_method_type& settingsType::
parallelisation_method ()
{
  return this->parallelisation_method_.get ();
}

void settingsType::
parallelisation_method (const parallelisation_method_type& x)
{
  this->parallelisation_method_.set (x);
}

void settingsType::
parallelisation_method (::std::unique_ptr< parallelisation_method_type > x)
{
  this->parallelisation_method_.set (std::move (x));
}

const settingsType::force_calculation_method_type& settingsType::
force_calculation_method () const
{
  return this->force_calculation_method_.get ();
}

settingsType::force_calculation_method_type& settingsType::
force_calculation_method ()
{
  return this->force_calculation_method_.get ();
}

void settingsType::
force_calculation_method (const force_calculation_method_type& x)
{
  this->force_calculation_method_.set (x);
}

void settingsType::
force_calculation_method (::std::unique_ptr< force_calculation_method_type > x)
{
  this->force_calculation_method_.set (std::move (x));
}

const settingsType::rl_type& settingsType::
rl () const
{
  return this->rl_.get ();
}

settingsType::rl_type& settingsType::
rl ()
{
  return this->rl_.get ();
}

void settingsType::
rl (const rl_type& x)
{
  this->rl_.set (x);
}

void settingsType::
rl (::std::unique_ptr< rl_type > x)
{
  this->rl_.set (std::move (x));
}

const settingsType::id_optional& settingsType::
id () const
{
  return this->id_;
}

settingsType::id_optional& settingsType::
id ()
{
  return this->id_;
}

void settingsType::
id (const id_type& x)
{
  this->id_.set (x);
}

void settingsType::
id (const id_optional& x)
{
  this->id_ = x;
}

void settingsType::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// write_checkpointType
// 

const write_checkpointType::bol_optional& write_checkpointType::
bol () const
{
  return this->bol_;
}

write_checkpointType::bol_optional& write_checkpointType::
bol ()
{
  return this->bol_;
}

void write_checkpointType::
bol (const bol_type& x)
{
  this->bol_.set (x);
}

void write_checkpointType::
bol (const bol_optional& x)
{
  this->bol_ = x;
}

void write_checkpointType::
bol (::std::unique_ptr< bol_type > x)
{
  this->bol_.set (std::move (x));
}


// read_checkpointType
// 

const read_checkpointType::bol_optional& read_checkpointType::
bol () const
{
  return this->bol_;
}

read_checkpointType::bol_optional& read_checkpointType::
bol ()
{
  return this->bol_;
}

void read_checkpointType::
bol (const bol_type& x)
{
  this->bol_.set (x);
}

void read_checkpointType::
bol (const bol_optional& x)
{
  this->bol_ = x;
}

void read_checkpointType::
bol (::std::unique_ptr< bol_type > x)
{
  this->bol_.set (std::move (x));
}


// write_checkpoint_timeType
// 

const write_checkpoint_timeType::t_optional& write_checkpoint_timeType::
t () const
{
  return this->t_;
}

write_checkpoint_timeType::t_optional& write_checkpoint_timeType::
t ()
{
  return this->t_;
}

void write_checkpoint_timeType::
t (const t_type& x)
{
  this->t_.set (x);
}

void write_checkpoint_timeType::
t (const t_optional& x)
{
  this->t_ = x;
}

void write_checkpoint_timeType::
t (::std::unique_ptr< t_type > x)
{
  this->t_.set (std::move (x));
}


// checkpointType
// 

const checkpointType::write_checkpoint_type& checkpointType::
write_checkpoint () const
{
  return this->write_checkpoint_.get ();
}

checkpointType::write_checkpoint_type& checkpointType::
write_checkpoint ()
{
  return this->write_checkpoint_.get ();
}

void checkpointType::
write_checkpoint (const write_checkpoint_type& x)
{
  this->write_checkpoint_.set (x);
}

void checkpointType::
write_checkpoint (::std::unique_ptr< write_checkpoint_type > x)
{
  this->write_checkpoint_.set (std::move (x));
}

const checkpointType::read_checkpoint_type& checkpointType::
read_checkpoint () const
{
  return this->read_checkpoint_.get ();
}

checkpointType::read_checkpoint_type& checkpointType::
read_checkpoint ()
{
  return this->read_checkpoint_.get ();
}

void checkpointType::
read_checkpoint (const read_checkpoint_type& x)
{
  this->read_checkpoint_.set (x);
}

void checkpointType::
read_checkpoint (::std::unique_ptr< read_checkpoint_type > x)
{
  this->read_checkpoint_.set (std::move (x));
}

const checkpointType::write_checkpoint_time_type& checkpointType::
write_checkpoint_time () const
{
  return this->write_checkpoint_time_.get ();
}

checkpointType::write_checkpoint_time_type& checkpointType::
write_checkpoint_time ()
{
  return this->write_checkpoint_time_.get ();
}

void checkpointType::
write_checkpoint_time (const write_checkpoint_time_type& x)
{
  this->write_checkpoint_time_.set (x);
}

void checkpointType::
write_checkpoint_time (::std::unique_ptr< write_checkpoint_time_type > x)
{
  this->write_checkpoint_time_.set (std::move (x));
}

const checkpointType::id_optional& checkpointType::
id () const
{
  return this->id_;
}

checkpointType::id_optional& checkpointType::
id ()
{
  return this->id_;
}

void checkpointType::
id (const id_type& x)
{
  this->id_.set (x);
}

void checkpointType::
id (const id_optional& x)
{
  this->id_ = x;
}

void checkpointType::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// typeType
// 

const typeType::val_optional& typeType::
val () const
{
  return this->val_;
}

typeType::val_optional& typeType::
val ()
{
  return this->val_;
}

void typeType::
val (const val_type& x)
{
  this->val_.set (x);
}

void typeType::
val (const val_optional& x)
{
  this->val_ = x;
}

void typeType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// epsilonType
// 

const epsilonType::val_optional& epsilonType::
val () const
{
  return this->val_;
}

epsilonType::val_optional& epsilonType::
val ()
{
  return this->val_;
}

void epsilonType::
val (const val_type& x)
{
  this->val_.set (x);
}

void epsilonType::
val (const val_optional& x)
{
  this->val_ = x;
}

void epsilonType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// sigmaType
// 

const sigmaType::val_optional& sigmaType::
val () const
{
  return this->val_;
}

sigmaType::val_optional& sigmaType::
val ()
{
  return this->val_;
}

void sigmaType::
val (const val_type& x)
{
  this->val_.set (x);
}

void sigmaType::
val (const val_optional& x)
{
  this->val_ = x;
}

void sigmaType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// centreType
// 

const centreType::x_optional& centreType::
x () const
{
  return this->x_;
}

centreType::x_optional& centreType::
x ()
{
  return this->x_;
}

void centreType::
x (const x_type& x)
{
  this->x_.set (x);
}

void centreType::
x (const x_optional& x)
{
  this->x_ = x;
}

void centreType::
x (::std::unique_ptr< x_type > x)
{
  this->x_.set (std::move (x));
}

const centreType::y_optional& centreType::
y () const
{
  return this->y_;
}

centreType::y_optional& centreType::
y ()
{
  return this->y_;
}

void centreType::
y (const y_type& x)
{
  this->y_.set (x);
}

void centreType::
y (const y_optional& x)
{
  this->y_ = x;
}

void centreType::
y (::std::unique_ptr< y_type > x)
{
  this->y_.set (std::move (x));
}

const centreType::z_optional& centreType::
z () const
{
  return this->z_;
}

centreType::z_optional& centreType::
z ()
{
  return this->z_;
}

void centreType::
z (const z_type& x)
{
  this->z_.set (x);
}

void centreType::
z (const z_optional& x)
{
  this->z_ = x;
}

void centreType::
z (::std::unique_ptr< z_type > x)
{
  this->z_.set (std::move (x));
}


// radiusType
// 

const radiusType::val_optional& radiusType::
val () const
{
  return this->val_;
}

radiusType::val_optional& radiusType::
val ()
{
  return this->val_;
}

void radiusType::
val (const val_type& x)
{
  this->val_.set (x);
}

void radiusType::
val (const val_optional& x)
{
  this->val_ = x;
}

void radiusType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// velocityType
// 

const velocityType::x_optional& velocityType::
x () const
{
  return this->x_;
}

velocityType::x_optional& velocityType::
x ()
{
  return this->x_;
}

void velocityType::
x (const x_type& x)
{
  this->x_.set (x);
}

void velocityType::
x (const x_optional& x)
{
  this->x_ = x;
}

void velocityType::
x (::std::unique_ptr< x_type > x)
{
  this->x_.set (std::move (x));
}

const velocityType::y_optional& velocityType::
y () const
{
  return this->y_;
}

velocityType::y_optional& velocityType::
y ()
{
  return this->y_;
}

void velocityType::
y (const y_type& x)
{
  this->y_.set (x);
}

void velocityType::
y (const y_optional& x)
{
  this->y_ = x;
}

void velocityType::
y (::std::unique_ptr< y_type > x)
{
  this->y_.set (std::move (x));
}

const velocityType::z_optional& velocityType::
z () const
{
  return this->z_;
}

velocityType::z_optional& velocityType::
z ()
{
  return this->z_;
}

void velocityType::
z (const z_type& x)
{
  this->z_.set (x);
}

void velocityType::
z (const z_optional& x)
{
  this->z_ = x;
}

void velocityType::
z (::std::unique_ptr< z_type > x)
{
  this->z_.set (std::move (x));
}


// massType
// 

const massType::val_optional& massType::
val () const
{
  return this->val_;
}

massType::val_optional& massType::
val ()
{
  return this->val_;
}

void massType::
val (const val_type& x)
{
  this->val_.set (x);
}

void massType::
val (const val_optional& x)
{
  this->val_ = x;
}

void massType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// hType
// 

const hType::val_optional& hType::
val () const
{
  return this->val_;
}

hType::val_optional& hType::
val ()
{
  return this->val_;
}

void hType::
val (const val_type& x)
{
  this->val_.set (x);
}

void hType::
val (const val_optional& x)
{
  this->val_ = x;
}

void hType::
val (::std::unique_ptr< val_type > x)
{
  this->val_.set (std::move (x));
}


// sphereType
// 

const sphereType::type_type& sphereType::
type () const
{
  return this->type_.get ();
}

sphereType::type_type& sphereType::
type ()
{
  return this->type_.get ();
}

void sphereType::
type (const type_type& x)
{
  this->type_.set (x);
}

void sphereType::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const sphereType::epsilon_type& sphereType::
epsilon () const
{
  return this->epsilon_.get ();
}

sphereType::epsilon_type& sphereType::
epsilon ()
{
  return this->epsilon_.get ();
}

void sphereType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

void sphereType::
epsilon (::std::unique_ptr< epsilon_type > x)
{
  this->epsilon_.set (std::move (x));
}

const sphereType::sigma_type& sphereType::
sigma () const
{
  return this->sigma_.get ();
}

sphereType::sigma_type& sphereType::
sigma ()
{
  return this->sigma_.get ();
}

void sphereType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

void sphereType::
sigma (::std::unique_ptr< sigma_type > x)
{
  this->sigma_.set (std::move (x));
}

const sphereType::centre_type& sphereType::
centre () const
{
  return this->centre_.get ();
}

sphereType::centre_type& sphereType::
centre ()
{
  return this->centre_.get ();
}

void sphereType::
centre (const centre_type& x)
{
  this->centre_.set (x);
}

void sphereType::
centre (::std::unique_ptr< centre_type > x)
{
  this->centre_.set (std::move (x));
}

const sphereType::radius_type& sphereType::
radius () const
{
  return this->radius_.get ();
}

sphereType::radius_type& sphereType::
radius ()
{
  return this->radius_.get ();
}

void sphereType::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void sphereType::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}

const sphereType::velocity_type& sphereType::
velocity () const
{
  return this->velocity_.get ();
}

sphereType::velocity_type& sphereType::
velocity ()
{
  return this->velocity_.get ();
}

void sphereType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void sphereType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const sphereType::mass_type& sphereType::
mass () const
{
  return this->mass_.get ();
}

sphereType::mass_type& sphereType::
mass ()
{
  return this->mass_.get ();
}

void sphereType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void sphereType::
mass (::std::unique_ptr< mass_type > x)
{
  this->mass_.set (std::move (x));
}

const sphereType::h_type& sphereType::
h () const
{
  return this->h_.get ();
}

sphereType::h_type& sphereType::
h ()
{
  return this->h_.get ();
}

void sphereType::
h (const h_type& x)
{
  this->h_.set (x);
}

void sphereType::
h (::std::unique_ptr< h_type > x)
{
  this->h_.set (std::move (x));
}

const sphereType::id_optional& sphereType::
id () const
{
  return this->id_;
}

sphereType::id_optional& sphereType::
id ()
{
  return this->id_;
}

void sphereType::
id (const id_type& x)
{
  this->id_.set (x);
}

void sphereType::
id (const id_optional& x)
{
  this->id_ = x;
}

void sphereType::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// right_top_pointType
// 

const right_top_pointType::x_optional& right_top_pointType::
x () const
{
  return this->x_;
}

right_top_pointType::x_optional& right_top_pointType::
x ()
{
  return this->x_;
}

void right_top_pointType::
x (const x_type& x)
{
  this->x_.set (x);
}

void right_top_pointType::
x (const x_optional& x)
{
  this->x_ = x;
}

void right_top_pointType::
x (::std::unique_ptr< x_type > x)
{
  this->x_.set (std::move (x));
}

const right_top_pointType::y_optional& right_top_pointType::
y () const
{
  return this->y_;
}

right_top_pointType::y_optional& right_top_pointType::
y ()
{
  return this->y_;
}

void right_top_pointType::
y (const y_type& x)
{
  this->y_.set (x);
}

void right_top_pointType::
y (const y_optional& x)
{
  this->y_ = x;
}

void right_top_pointType::
y (::std::unique_ptr< y_type > x)
{
  this->y_.set (std::move (x));
}

const right_top_pointType::z_optional& right_top_pointType::
z () const
{
  return this->z_;
}

right_top_pointType::z_optional& right_top_pointType::
z ()
{
  return this->z_;
}

void right_top_pointType::
z (const z_type& x)
{
  this->z_.set (x);
}

void right_top_pointType::
z (const z_optional& x)
{
  this->z_ = x;
}

void right_top_pointType::
z (::std::unique_ptr< z_type > x)
{
  this->z_.set (std::move (x));
}


// side_lengthsType
// 

const side_lengthsType::x_optional& side_lengthsType::
x () const
{
  return this->x_;
}

side_lengthsType::x_optional& side_lengthsType::
x ()
{
  return this->x_;
}

void side_lengthsType::
x (const x_type& x)
{
  this->x_.set (x);
}

void side_lengthsType::
x (const x_optional& x)
{
  this->x_ = x;
}

void side_lengthsType::
x (::std::unique_ptr< x_type > x)
{
  this->x_.set (std::move (x));
}

const side_lengthsType::y_optional& side_lengthsType::
y () const
{
  return this->y_;
}

side_lengthsType::y_optional& side_lengthsType::
y ()
{
  return this->y_;
}

void side_lengthsType::
y (const y_type& x)
{
  this->y_.set (x);
}

void side_lengthsType::
y (const y_optional& x)
{
  this->y_ = x;
}

void side_lengthsType::
y (::std::unique_ptr< y_type > x)
{
  this->y_.set (std::move (x));
}

const side_lengthsType::z_optional& side_lengthsType::
z () const
{
  return this->z_;
}

side_lengthsType::z_optional& side_lengthsType::
z ()
{
  return this->z_;
}

void side_lengthsType::
z (const z_type& x)
{
  this->z_.set (x);
}

void side_lengthsType::
z (const z_optional& x)
{
  this->z_ = x;
}

void side_lengthsType::
z (::std::unique_ptr< z_type > x)
{
  this->z_.set (std::move (x));
}


// membraneType
// 

const membraneType::bol_optional& membraneType::
bol () const
{
  return this->bol_;
}

membraneType::bol_optional& membraneType::
bol ()
{
  return this->bol_;
}

void membraneType::
bol (const bol_type& x)
{
  this->bol_.set (x);
}

void membraneType::
bol (const bol_optional& x)
{
  this->bol_ = x;
}

void membraneType::
bol (::std::unique_ptr< bol_type > x)
{
  this->bol_.set (std::move (x));
}


// cuboidType
// 

const cuboidType::type_type& cuboidType::
type () const
{
  return this->type_.get ();
}

cuboidType::type_type& cuboidType::
type ()
{
  return this->type_.get ();
}

void cuboidType::
type (const type_type& x)
{
  this->type_.set (x);
}

void cuboidType::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const cuboidType::epsilon_type& cuboidType::
epsilon () const
{
  return this->epsilon_.get ();
}

cuboidType::epsilon_type& cuboidType::
epsilon ()
{
  return this->epsilon_.get ();
}

void cuboidType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

void cuboidType::
epsilon (::std::unique_ptr< epsilon_type > x)
{
  this->epsilon_.set (std::move (x));
}

const cuboidType::sigma_type& cuboidType::
sigma () const
{
  return this->sigma_.get ();
}

cuboidType::sigma_type& cuboidType::
sigma ()
{
  return this->sigma_.get ();
}

void cuboidType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

void cuboidType::
sigma (::std::unique_ptr< sigma_type > x)
{
  this->sigma_.set (std::move (x));
}

const cuboidType::right_top_point_type& cuboidType::
right_top_point () const
{
  return this->right_top_point_.get ();
}

cuboidType::right_top_point_type& cuboidType::
right_top_point ()
{
  return this->right_top_point_.get ();
}

void cuboidType::
right_top_point (const right_top_point_type& x)
{
  this->right_top_point_.set (x);
}

void cuboidType::
right_top_point (::std::unique_ptr< right_top_point_type > x)
{
  this->right_top_point_.set (std::move (x));
}

const cuboidType::side_lengths_type& cuboidType::
side_lengths () const
{
  return this->side_lengths_.get ();
}

cuboidType::side_lengths_type& cuboidType::
side_lengths ()
{
  return this->side_lengths_.get ();
}

void cuboidType::
side_lengths (const side_lengths_type& x)
{
  this->side_lengths_.set (x);
}

void cuboidType::
side_lengths (::std::unique_ptr< side_lengths_type > x)
{
  this->side_lengths_.set (std::move (x));
}

const cuboidType::velocity_type& cuboidType::
velocity () const
{
  return this->velocity_.get ();
}

cuboidType::velocity_type& cuboidType::
velocity ()
{
  return this->velocity_.get ();
}

void cuboidType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboidType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const cuboidType::mass_type& cuboidType::
mass () const
{
  return this->mass_.get ();
}

cuboidType::mass_type& cuboidType::
mass ()
{
  return this->mass_.get ();
}

void cuboidType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void cuboidType::
mass (::std::unique_ptr< mass_type > x)
{
  this->mass_.set (std::move (x));
}

const cuboidType::h_type& cuboidType::
h () const
{
  return this->h_.get ();
}

cuboidType::h_type& cuboidType::
h ()
{
  return this->h_.get ();
}

void cuboidType::
h (const h_type& x)
{
  this->h_.set (x);
}

void cuboidType::
h (::std::unique_ptr< h_type > x)
{
  this->h_.set (std::move (x));
}

const cuboidType::membrane_type& cuboidType::
membrane () const
{
  return this->membrane_.get ();
}

cuboidType::membrane_type& cuboidType::
membrane ()
{
  return this->membrane_.get ();
}

void cuboidType::
membrane (const membrane_type& x)
{
  this->membrane_.set (x);
}

void cuboidType::
membrane (::std::unique_ptr< membrane_type > x)
{
  this->membrane_.set (std::move (x));
}

const cuboidType::id_optional& cuboidType::
id () const
{
  return this->id_;
}

cuboidType::id_optional& cuboidType::
id ()
{
  return this->id_;
}

void cuboidType::
id (const id_type& x)
{
  this->id_.set (x);
}

void cuboidType::
id (const id_optional& x)
{
  this->id_ = x;
}

void cuboidType::
id (::std::unique_ptr< id_type > x)
{
  this->id_.set (std::move (x));
}


// shapesType
// 

const shapesType::settings_type& shapesType::
settings () const
{
  return this->settings_.get ();
}

shapesType::settings_type& shapesType::
settings ()
{
  return this->settings_.get ();
}

void shapesType::
settings (const settings_type& x)
{
  this->settings_.set (x);
}

void shapesType::
settings (::std::unique_ptr< settings_type > x)
{
  this->settings_.set (std::move (x));
}

const shapesType::checkpoint_optional& shapesType::
checkpoint () const
{
  return this->checkpoint_;
}

shapesType::checkpoint_optional& shapesType::
checkpoint ()
{
  return this->checkpoint_;
}

void shapesType::
checkpoint (const checkpoint_type& x)
{
  this->checkpoint_.set (x);
}

void shapesType::
checkpoint (const checkpoint_optional& x)
{
  this->checkpoint_ = x;
}

void shapesType::
checkpoint (::std::unique_ptr< checkpoint_type > x)
{
  this->checkpoint_.set (std::move (x));
}

const shapesType::sphere_sequence& shapesType::
sphere () const
{
  return this->sphere_;
}

shapesType::sphere_sequence& shapesType::
sphere ()
{
  return this->sphere_;
}

void shapesType::
sphere (const sphere_sequence& s)
{
  this->sphere_ = s;
}

const shapesType::cuboid_sequence& shapesType::
cuboid () const
{
  return this->cuboid_;
}

shapesType::cuboid_sequence& shapesType::
cuboid ()
{
  return this->cuboid_;
}

void shapesType::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// delta_tType
//

delta_tType::
delta_tType ()
: ::xml_schema::string (),
  t_ (this)
{
}

delta_tType::
delta_tType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

delta_tType::
delta_tType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

delta_tType::
delta_tType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

delta_tType::
delta_tType (const delta_tType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  t_ (x.t_, f, this)
{
}

delta_tType::
delta_tType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  t_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void delta_tType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }
  }
}

delta_tType* delta_tType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class delta_tType (*this, f, c);
}

delta_tType& delta_tType::
operator= (const delta_tType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->t_ = x.t_;
  }

  return *this;
}

delta_tType::
~delta_tType ()
{
}

// end_timeType
//

end_timeType::
end_timeType ()
: ::xml_schema::string (),
  t_ (this)
{
}

end_timeType::
end_timeType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

end_timeType::
end_timeType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

end_timeType::
end_timeType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

end_timeType::
end_timeType (const end_timeType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  t_ (x.t_, f, this)
{
}

end_timeType::
end_timeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  t_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void end_timeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }
  }
}

end_timeType* end_timeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class end_timeType (*this, f, c);
}

end_timeType& end_timeType::
operator= (const end_timeType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->t_ = x.t_;
  }

  return *this;
}

end_timeType::
~end_timeType ()
{
}

// factorType
//

factorType::
factorType ()
: ::xml_schema::string (),
  val_ (this)
{
}

factorType::
factorType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

factorType::
factorType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

factorType::
factorType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

factorType::
factorType (const factorType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

factorType::
factorType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void factorType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

factorType* factorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class factorType (*this, f, c);
}

factorType& factorType::
operator= (const factorType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

factorType::
~factorType ()
{
}

// domain_sizeType
//

domain_sizeType::
domain_sizeType ()
: ::xml_schema::string (),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

domain_sizeType::
domain_sizeType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

domain_sizeType::
domain_sizeType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

domain_sizeType::
domain_sizeType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

domain_sizeType::
domain_sizeType (const domain_sizeType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

domain_sizeType::
domain_sizeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void domain_sizeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }
}

domain_sizeType* domain_sizeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class domain_sizeType (*this, f, c);
}

domain_sizeType& domain_sizeType::
operator= (const domain_sizeType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

domain_sizeType::
~domain_sizeType ()
{
}

// rcutoffType
//

rcutoffType::
rcutoffType ()
: ::xml_schema::string (),
  val_ (this)
{
}

rcutoffType::
rcutoffType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

rcutoffType::
rcutoffType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

rcutoffType::
rcutoffType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

rcutoffType::
rcutoffType (const rcutoffType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

rcutoffType::
rcutoffType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void rcutoffType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

rcutoffType* rcutoffType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class rcutoffType (*this, f, c);
}

rcutoffType& rcutoffType::
operator= (const rcutoffType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

rcutoffType::
~rcutoffType ()
{
}

// x1_boundary_conditionType
//

x1_boundary_conditionType::
x1_boundary_conditionType ()
: ::xml_schema::string (),
  val_ (this)
{
}

x1_boundary_conditionType::
x1_boundary_conditionType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

x1_boundary_conditionType::
x1_boundary_conditionType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

x1_boundary_conditionType::
x1_boundary_conditionType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

x1_boundary_conditionType::
x1_boundary_conditionType (const x1_boundary_conditionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

x1_boundary_conditionType::
x1_boundary_conditionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void x1_boundary_conditionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

x1_boundary_conditionType* x1_boundary_conditionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class x1_boundary_conditionType (*this, f, c);
}

x1_boundary_conditionType& x1_boundary_conditionType::
operator= (const x1_boundary_conditionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

x1_boundary_conditionType::
~x1_boundary_conditionType ()
{
}

// x2_boundary_conditionType
//

x2_boundary_conditionType::
x2_boundary_conditionType ()
: ::xml_schema::string (),
  val_ (this)
{
}

x2_boundary_conditionType::
x2_boundary_conditionType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

x2_boundary_conditionType::
x2_boundary_conditionType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

x2_boundary_conditionType::
x2_boundary_conditionType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

x2_boundary_conditionType::
x2_boundary_conditionType (const x2_boundary_conditionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

x2_boundary_conditionType::
x2_boundary_conditionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void x2_boundary_conditionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

x2_boundary_conditionType* x2_boundary_conditionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class x2_boundary_conditionType (*this, f, c);
}

x2_boundary_conditionType& x2_boundary_conditionType::
operator= (const x2_boundary_conditionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

x2_boundary_conditionType::
~x2_boundary_conditionType ()
{
}

// y1_boundary_conditionType
//

y1_boundary_conditionType::
y1_boundary_conditionType ()
: ::xml_schema::string (),
  val_ (this)
{
}

y1_boundary_conditionType::
y1_boundary_conditionType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

y1_boundary_conditionType::
y1_boundary_conditionType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

y1_boundary_conditionType::
y1_boundary_conditionType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

y1_boundary_conditionType::
y1_boundary_conditionType (const y1_boundary_conditionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

y1_boundary_conditionType::
y1_boundary_conditionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void y1_boundary_conditionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

y1_boundary_conditionType* y1_boundary_conditionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class y1_boundary_conditionType (*this, f, c);
}

y1_boundary_conditionType& y1_boundary_conditionType::
operator= (const y1_boundary_conditionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

y1_boundary_conditionType::
~y1_boundary_conditionType ()
{
}

// y2_boundary_conditionType
//

y2_boundary_conditionType::
y2_boundary_conditionType ()
: ::xml_schema::string (),
  val_ (this)
{
}

y2_boundary_conditionType::
y2_boundary_conditionType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

y2_boundary_conditionType::
y2_boundary_conditionType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

y2_boundary_conditionType::
y2_boundary_conditionType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

y2_boundary_conditionType::
y2_boundary_conditionType (const y2_boundary_conditionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

y2_boundary_conditionType::
y2_boundary_conditionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void y2_boundary_conditionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

y2_boundary_conditionType* y2_boundary_conditionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class y2_boundary_conditionType (*this, f, c);
}

y2_boundary_conditionType& y2_boundary_conditionType::
operator= (const y2_boundary_conditionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

y2_boundary_conditionType::
~y2_boundary_conditionType ()
{
}

// z1_boundary_conditionType
//

z1_boundary_conditionType::
z1_boundary_conditionType ()
: ::xml_schema::string (),
  val_ (this)
{
}

z1_boundary_conditionType::
z1_boundary_conditionType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

z1_boundary_conditionType::
z1_boundary_conditionType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

z1_boundary_conditionType::
z1_boundary_conditionType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

z1_boundary_conditionType::
z1_boundary_conditionType (const z1_boundary_conditionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

z1_boundary_conditionType::
z1_boundary_conditionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void z1_boundary_conditionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

z1_boundary_conditionType* z1_boundary_conditionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class z1_boundary_conditionType (*this, f, c);
}

z1_boundary_conditionType& z1_boundary_conditionType::
operator= (const z1_boundary_conditionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

z1_boundary_conditionType::
~z1_boundary_conditionType ()
{
}

// z2_boundary_conditionType
//

z2_boundary_conditionType::
z2_boundary_conditionType ()
: ::xml_schema::string (),
  val_ (this)
{
}

z2_boundary_conditionType::
z2_boundary_conditionType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

z2_boundary_conditionType::
z2_boundary_conditionType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

z2_boundary_conditionType::
z2_boundary_conditionType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

z2_boundary_conditionType::
z2_boundary_conditionType (const z2_boundary_conditionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

z2_boundary_conditionType::
z2_boundary_conditionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void z2_boundary_conditionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

z2_boundary_conditionType* z2_boundary_conditionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class z2_boundary_conditionType (*this, f, c);
}

z2_boundary_conditionType& z2_boundary_conditionType::
operator= (const z2_boundary_conditionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

z2_boundary_conditionType::
~z2_boundary_conditionType ()
{
}

// brownian_motionType
//

brownian_motionType::
brownian_motionType ()
: ::xml_schema::string (),
  bol_ (this)
{
}

brownian_motionType::
brownian_motionType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

brownian_motionType::
brownian_motionType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

brownian_motionType::
brownian_motionType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

brownian_motionType::
brownian_motionType (const brownian_motionType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  bol_ (x.bol_, f, this)
{
}

brownian_motionType::
brownian_motionType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  bol_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void brownian_motionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bol" && n.namespace_ ().empty ())
    {
      this->bol_.set (bol_traits::create (i, f, this));
      continue;
    }
  }
}

brownian_motionType* brownian_motionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class brownian_motionType (*this, f, c);
}

brownian_motionType& brownian_motionType::
operator= (const brownian_motionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->bol_ = x.bol_;
  }

  return *this;
}

brownian_motionType::
~brownian_motionType ()
{
}

// initial_temperatureType
//

initial_temperatureType::
initial_temperatureType ()
: ::xml_schema::string (),
  val_ (this)
{
}

initial_temperatureType::
initial_temperatureType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

initial_temperatureType::
initial_temperatureType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

initial_temperatureType::
initial_temperatureType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

initial_temperatureType::
initial_temperatureType (const initial_temperatureType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

initial_temperatureType::
initial_temperatureType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void initial_temperatureType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

initial_temperatureType* initial_temperatureType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class initial_temperatureType (*this, f, c);
}

initial_temperatureType& initial_temperatureType::
operator= (const initial_temperatureType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

initial_temperatureType::
~initial_temperatureType ()
{
}

// n_thermostatType
//

n_thermostatType::
n_thermostatType ()
: ::xml_schema::string (),
  t_ (this)
{
}

n_thermostatType::
n_thermostatType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

n_thermostatType::
n_thermostatType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

n_thermostatType::
n_thermostatType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

n_thermostatType::
n_thermostatType (const n_thermostatType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  t_ (x.t_, f, this)
{
}

n_thermostatType::
n_thermostatType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  t_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void n_thermostatType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }
  }
}

n_thermostatType* n_thermostatType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class n_thermostatType (*this, f, c);
}

n_thermostatType& n_thermostatType::
operator= (const n_thermostatType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->t_ = x.t_;
  }

  return *this;
}

n_thermostatType::
~n_thermostatType ()
{
}

// target_temperatureType
//

target_temperatureType::
target_temperatureType ()
: ::xml_schema::string (),
  val_ (this)
{
}

target_temperatureType::
target_temperatureType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

target_temperatureType::
target_temperatureType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

target_temperatureType::
target_temperatureType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

target_temperatureType::
target_temperatureType (const target_temperatureType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

target_temperatureType::
target_temperatureType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void target_temperatureType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

target_temperatureType* target_temperatureType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class target_temperatureType (*this, f, c);
}

target_temperatureType& target_temperatureType::
operator= (const target_temperatureType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

target_temperatureType::
~target_temperatureType ()
{
}

// temperature_differenceType
//

temperature_differenceType::
temperature_differenceType ()
: ::xml_schema::string (),
  val_ (this)
{
}

temperature_differenceType::
temperature_differenceType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

temperature_differenceType::
temperature_differenceType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

temperature_differenceType::
temperature_differenceType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

temperature_differenceType::
temperature_differenceType (const temperature_differenceType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

temperature_differenceType::
temperature_differenceType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void temperature_differenceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

temperature_differenceType* temperature_differenceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class temperature_differenceType (*this, f, c);
}

temperature_differenceType& temperature_differenceType::
operator= (const temperature_differenceType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

temperature_differenceType::
~temperature_differenceType ()
{
}

// gravitationType
//

gravitationType::
gravitationType ()
: ::xml_schema::string (),
  val_ (this)
{
}

gravitationType::
gravitationType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

gravitationType::
gravitationType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

gravitationType::
gravitationType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

gravitationType::
gravitationType (const gravitationType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

gravitationType::
gravitationType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void gravitationType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

gravitationType* gravitationType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravitationType (*this, f, c);
}

gravitationType& gravitationType::
operator= (const gravitationType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

gravitationType::
~gravitationType ()
{
}

// r0Type
//

r0Type::
r0Type ()
: ::xml_schema::string (),
  val_ (this)
{
}

r0Type::
r0Type (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

r0Type::
r0Type (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

r0Type::
r0Type (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

r0Type::
r0Type (const r0Type& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

r0Type::
r0Type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void r0Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

r0Type* r0Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class r0Type (*this, f, c);
}

r0Type& r0Type::
operator= (const r0Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

r0Type::
~r0Type ()
{
}

// kType
//

kType::
kType ()
: ::xml_schema::string (),
  val_ (this)
{
}

kType::
kType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

kType::
kType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

kType::
kType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

kType::
kType (const kType& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

kType::
kType (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void kType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

kType* kType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class kType (*this, f, c);
}

kType& kType::
operator= (const kType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

kType::
~kType ()
{
}

// fz_upType
//

fz_upType::
fz_upType ()
: ::xml_schema::string (),
  val_ (this)
{
}

fz_upType::
fz_upType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

fz_upType::
fz_upType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

fz_upType::
fz_upType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

fz_upType::
fz_upType (const fz_upType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

fz_upType::
fz_upType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void fz_upType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

fz_upType* fz_upType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class fz_upType (*this, f, c);
}

fz_upType& fz_upType::
operator= (const fz_upType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

fz_upType::
~fz_upType ()
{
}

// parallelisation_methodType
//

parallelisation_methodType::
parallelisation_methodType ()
: ::xml_schema::string (),
  val_ (this)
{
}

parallelisation_methodType::
parallelisation_methodType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

parallelisation_methodType::
parallelisation_methodType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

parallelisation_methodType::
parallelisation_methodType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

parallelisation_methodType::
parallelisation_methodType (const parallelisation_methodType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

parallelisation_methodType::
parallelisation_methodType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void parallelisation_methodType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

parallelisation_methodType* parallelisation_methodType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parallelisation_methodType (*this, f, c);
}

parallelisation_methodType& parallelisation_methodType::
operator= (const parallelisation_methodType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

parallelisation_methodType::
~parallelisation_methodType ()
{
}

// force_calculation_methodType
//

force_calculation_methodType::
force_calculation_methodType ()
: ::xml_schema::string (),
  val_ (this)
{
}

force_calculation_methodType::
force_calculation_methodType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

force_calculation_methodType::
force_calculation_methodType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

force_calculation_methodType::
force_calculation_methodType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

force_calculation_methodType::
force_calculation_methodType (const force_calculation_methodType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

force_calculation_methodType::
force_calculation_methodType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void force_calculation_methodType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

force_calculation_methodType* force_calculation_methodType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class force_calculation_methodType (*this, f, c);
}

force_calculation_methodType& force_calculation_methodType::
operator= (const force_calculation_methodType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

force_calculation_methodType::
~force_calculation_methodType ()
{
}

// rlType
//

rlType::
rlType ()
: ::xml_schema::string (),
  val_ (this)
{
}

rlType::
rlType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

rlType::
rlType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

rlType::
rlType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

rlType::
rlType (const rlType& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

rlType::
rlType (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void rlType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

rlType* rlType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class rlType (*this, f, c);
}

rlType& rlType::
operator= (const rlType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

rlType::
~rlType ()
{
}

// settingsType
//

settingsType::
settingsType (const delta_t_type& delta_t,
              const end_time_type& end_time,
              const factor_type& factor,
              const domain_size_type& domain_size,
              const rcutoff_type& rcutoff,
              const x1_boundary_condition_type& x1_boundary_condition,
              const x2_boundary_condition_type& x2_boundary_condition,
              const y1_boundary_condition_type& y1_boundary_condition,
              const y2_boundary_condition_type& y2_boundary_condition,
              const z1_boundary_condition_type& z1_boundary_condition,
              const z2_boundary_condition_type& z2_boundary_condition,
              const brownian_motion_type& brownian_motion,
              const initial_temperature_type& initial_temperature,
              const n_thermostat_type& n_thermostat,
              const target_temperature_type& target_temperature,
              const temperature_difference_type& temperature_difference,
              const gravitation_type& gravitation,
              const r0_type& r0,
              const k_type& k,
              const fz_up_type& fz_up,
              const parallelisation_method_type& parallelisation_method,
              const force_calculation_method_type& force_calculation_method,
              const rl_type& rl)
: ::xml_schema::type (),
  delta_t_ (delta_t, this),
  end_time_ (end_time, this),
  factor_ (factor, this),
  domain_size_ (domain_size, this),
  rcutoff_ (rcutoff, this),
  x1_boundary_condition_ (x1_boundary_condition, this),
  x2_boundary_condition_ (x2_boundary_condition, this),
  y1_boundary_condition_ (y1_boundary_condition, this),
  y2_boundary_condition_ (y2_boundary_condition, this),
  z1_boundary_condition_ (z1_boundary_condition, this),
  z2_boundary_condition_ (z2_boundary_condition, this),
  brownian_motion_ (brownian_motion, this),
  initial_temperature_ (initial_temperature, this),
  n_thermostat_ (n_thermostat, this),
  target_temperature_ (target_temperature, this),
  temperature_difference_ (temperature_difference, this),
  gravitation_ (gravitation, this),
  r0_ (r0, this),
  k_ (k, this),
  fz_up_ (fz_up, this),
  parallelisation_method_ (parallelisation_method, this),
  force_calculation_method_ (force_calculation_method, this),
  rl_ (rl, this),
  id_ (this)
{
}

settingsType::
settingsType (::std::unique_ptr< delta_t_type > delta_t,
              ::std::unique_ptr< end_time_type > end_time,
              ::std::unique_ptr< factor_type > factor,
              ::std::unique_ptr< domain_size_type > domain_size,
              ::std::unique_ptr< rcutoff_type > rcutoff,
              ::std::unique_ptr< x1_boundary_condition_type > x1_boundary_condition,
              ::std::unique_ptr< x2_boundary_condition_type > x2_boundary_condition,
              ::std::unique_ptr< y1_boundary_condition_type > y1_boundary_condition,
              ::std::unique_ptr< y2_boundary_condition_type > y2_boundary_condition,
              ::std::unique_ptr< z1_boundary_condition_type > z1_boundary_condition,
              ::std::unique_ptr< z2_boundary_condition_type > z2_boundary_condition,
              ::std::unique_ptr< brownian_motion_type > brownian_motion,
              ::std::unique_ptr< initial_temperature_type > initial_temperature,
              ::std::unique_ptr< n_thermostat_type > n_thermostat,
              ::std::unique_ptr< target_temperature_type > target_temperature,
              ::std::unique_ptr< temperature_difference_type > temperature_difference,
              ::std::unique_ptr< gravitation_type > gravitation,
              ::std::unique_ptr< r0_type > r0,
              ::std::unique_ptr< k_type > k,
              ::std::unique_ptr< fz_up_type > fz_up,
              ::std::unique_ptr< parallelisation_method_type > parallelisation_method,
              ::std::unique_ptr< force_calculation_method_type > force_calculation_method,
              ::std::unique_ptr< rl_type > rl)
: ::xml_schema::type (),
  delta_t_ (std::move (delta_t), this),
  end_time_ (std::move (end_time), this),
  factor_ (std::move (factor), this),
  domain_size_ (std::move (domain_size), this),
  rcutoff_ (std::move (rcutoff), this),
  x1_boundary_condition_ (std::move (x1_boundary_condition), this),
  x2_boundary_condition_ (std::move (x2_boundary_condition), this),
  y1_boundary_condition_ (std::move (y1_boundary_condition), this),
  y2_boundary_condition_ (std::move (y2_boundary_condition), this),
  z1_boundary_condition_ (std::move (z1_boundary_condition), this),
  z2_boundary_condition_ (std::move (z2_boundary_condition), this),
  brownian_motion_ (std::move (brownian_motion), this),
  initial_temperature_ (std::move (initial_temperature), this),
  n_thermostat_ (std::move (n_thermostat), this),
  target_temperature_ (std::move (target_temperature), this),
  temperature_difference_ (std::move (temperature_difference), this),
  gravitation_ (std::move (gravitation), this),
  r0_ (std::move (r0), this),
  k_ (std::move (k), this),
  fz_up_ (std::move (fz_up), this),
  parallelisation_method_ (std::move (parallelisation_method), this),
  force_calculation_method_ (std::move (force_calculation_method), this),
  rl_ (std::move (rl), this),
  id_ (this)
{
}

settingsType::
settingsType (const settingsType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  delta_t_ (x.delta_t_, f, this),
  end_time_ (x.end_time_, f, this),
  factor_ (x.factor_, f, this),
  domain_size_ (x.domain_size_, f, this),
  rcutoff_ (x.rcutoff_, f, this),
  x1_boundary_condition_ (x.x1_boundary_condition_, f, this),
  x2_boundary_condition_ (x.x2_boundary_condition_, f, this),
  y1_boundary_condition_ (x.y1_boundary_condition_, f, this),
  y2_boundary_condition_ (x.y2_boundary_condition_, f, this),
  z1_boundary_condition_ (x.z1_boundary_condition_, f, this),
  z2_boundary_condition_ (x.z2_boundary_condition_, f, this),
  brownian_motion_ (x.brownian_motion_, f, this),
  initial_temperature_ (x.initial_temperature_, f, this),
  n_thermostat_ (x.n_thermostat_, f, this),
  target_temperature_ (x.target_temperature_, f, this),
  temperature_difference_ (x.temperature_difference_, f, this),
  gravitation_ (x.gravitation_, f, this),
  r0_ (x.r0_, f, this),
  k_ (x.k_, f, this),
  fz_up_ (x.fz_up_, f, this),
  parallelisation_method_ (x.parallelisation_method_, f, this),
  force_calculation_method_ (x.force_calculation_method_, f, this),
  rl_ (x.rl_, f, this),
  id_ (x.id_, f, this)
{
}

settingsType::
settingsType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  delta_t_ (this),
  end_time_ (this),
  factor_ (this),
  domain_size_ (this),
  rcutoff_ (this),
  x1_boundary_condition_ (this),
  x2_boundary_condition_ (this),
  y1_boundary_condition_ (this),
  y2_boundary_condition_ (this),
  z1_boundary_condition_ (this),
  z2_boundary_condition_ (this),
  brownian_motion_ (this),
  initial_temperature_ (this),
  n_thermostat_ (this),
  target_temperature_ (this),
  temperature_difference_ (this),
  gravitation_ (this),
  r0_ (this),
  k_ (this),
  fz_up_ (this),
  parallelisation_method_ (this),
  force_calculation_method_ (this),
  rl_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void settingsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // delta-t
    //
    if (n.name () == "delta-t" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< delta_t_type > r (
        delta_t_traits::create (i, f, this));

      if (!delta_t_.present ())
      {
        this->delta_t_.set (::std::move (r));
        continue;
      }
    }

    // end-time
    //
    if (n.name () == "end-time" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< end_time_type > r (
        end_time_traits::create (i, f, this));

      if (!end_time_.present ())
      {
        this->end_time_.set (::std::move (r));
        continue;
      }
    }

    // factor
    //
    if (n.name () == "factor" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< factor_type > r (
        factor_traits::create (i, f, this));

      if (!factor_.present ())
      {
        this->factor_.set (::std::move (r));
        continue;
      }
    }

    // domain-size
    //
    if (n.name () == "domain-size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (::std::move (r));
        continue;
      }
    }

    // rcutoff
    //
    if (n.name () == "rcutoff" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< rcutoff_type > r (
        rcutoff_traits::create (i, f, this));

      if (!rcutoff_.present ())
      {
        this->rcutoff_.set (::std::move (r));
        continue;
      }
    }

    // x1-boundary-condition
    //
    if (n.name () == "x1-boundary-condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< x1_boundary_condition_type > r (
        x1_boundary_condition_traits::create (i, f, this));

      if (!x1_boundary_condition_.present ())
      {
        this->x1_boundary_condition_.set (::std::move (r));
        continue;
      }
    }

    // x2-boundary-condition
    //
    if (n.name () == "x2-boundary-condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< x2_boundary_condition_type > r (
        x2_boundary_condition_traits::create (i, f, this));

      if (!x2_boundary_condition_.present ())
      {
        this->x2_boundary_condition_.set (::std::move (r));
        continue;
      }
    }

    // y1-boundary-condition
    //
    if (n.name () == "y1-boundary-condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< y1_boundary_condition_type > r (
        y1_boundary_condition_traits::create (i, f, this));

      if (!y1_boundary_condition_.present ())
      {
        this->y1_boundary_condition_.set (::std::move (r));
        continue;
      }
    }

    // y2-boundary-condition
    //
    if (n.name () == "y2-boundary-condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< y2_boundary_condition_type > r (
        y2_boundary_condition_traits::create (i, f, this));

      if (!y2_boundary_condition_.present ())
      {
        this->y2_boundary_condition_.set (::std::move (r));
        continue;
      }
    }

    // z1-boundary-condition
    //
    if (n.name () == "z1-boundary-condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< z1_boundary_condition_type > r (
        z1_boundary_condition_traits::create (i, f, this));

      if (!z1_boundary_condition_.present ())
      {
        this->z1_boundary_condition_.set (::std::move (r));
        continue;
      }
    }

    // z2-boundary-condition
    //
    if (n.name () == "z2-boundary-condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< z2_boundary_condition_type > r (
        z2_boundary_condition_traits::create (i, f, this));

      if (!z2_boundary_condition_.present ())
      {
        this->z2_boundary_condition_.set (::std::move (r));
        continue;
      }
    }

    // brownian-motion
    //
    if (n.name () == "brownian-motion" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< brownian_motion_type > r (
        brownian_motion_traits::create (i, f, this));

      if (!brownian_motion_.present ())
      {
        this->brownian_motion_.set (::std::move (r));
        continue;
      }
    }

    // initial-temperature
    //
    if (n.name () == "initial-temperature" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< initial_temperature_type > r (
        initial_temperature_traits::create (i, f, this));

      if (!initial_temperature_.present ())
      {
        this->initial_temperature_.set (::std::move (r));
        continue;
      }
    }

    // n-thermostat
    //
    if (n.name () == "n-thermostat" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< n_thermostat_type > r (
        n_thermostat_traits::create (i, f, this));

      if (!n_thermostat_.present ())
      {
        this->n_thermostat_.set (::std::move (r));
        continue;
      }
    }

    // target-temperature
    //
    if (n.name () == "target-temperature" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< target_temperature_type > r (
        target_temperature_traits::create (i, f, this));

      if (!target_temperature_.present ())
      {
        this->target_temperature_.set (::std::move (r));
        continue;
      }
    }

    // temperature-difference
    //
    if (n.name () == "temperature-difference" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< temperature_difference_type > r (
        temperature_difference_traits::create (i, f, this));

      if (!temperature_difference_.present ())
      {
        this->temperature_difference_.set (::std::move (r));
        continue;
      }
    }

    // gravitation
    //
    if (n.name () == "gravitation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravitation_type > r (
        gravitation_traits::create (i, f, this));

      if (!gravitation_.present ())
      {
        this->gravitation_.set (::std::move (r));
        continue;
      }
    }

    // r0
    //
    if (n.name () == "r0" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< r0_type > r (
        r0_traits::create (i, f, this));

      if (!r0_.present ())
      {
        this->r0_.set (::std::move (r));
        continue;
      }
    }

    // k
    //
    if (n.name () == "k" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< k_type > r (
        k_traits::create (i, f, this));

      if (!k_.present ())
      {
        this->k_.set (::std::move (r));
        continue;
      }
    }

    // fz-up
    //
    if (n.name () == "fz-up" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< fz_up_type > r (
        fz_up_traits::create (i, f, this));

      if (!fz_up_.present ())
      {
        this->fz_up_.set (::std::move (r));
        continue;
      }
    }

    // parallelisation-method
    //
    if (n.name () == "parallelisation-method" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< parallelisation_method_type > r (
        parallelisation_method_traits::create (i, f, this));

      if (!parallelisation_method_.present ())
      {
        this->parallelisation_method_.set (::std::move (r));
        continue;
      }
    }

    // force-calculation-method
    //
    if (n.name () == "force-calculation-method" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< force_calculation_method_type > r (
        force_calculation_method_traits::create (i, f, this));

      if (!force_calculation_method_.present ())
      {
        this->force_calculation_method_.set (::std::move (r));
        continue;
      }
    }

    // rl
    //
    if (n.name () == "rl" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< rl_type > r (
        rl_traits::create (i, f, this));

      if (!rl_.present ())
      {
        this->rl_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta-t",
      "");
  }

  if (!end_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "end-time",
      "");
  }

  if (!factor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "factor",
      "");
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain-size",
      "");
  }

  if (!rcutoff_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rcutoff",
      "");
  }

  if (!x1_boundary_condition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x1-boundary-condition",
      "");
  }

  if (!x2_boundary_condition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x2-boundary-condition",
      "");
  }

  if (!y1_boundary_condition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y1-boundary-condition",
      "");
  }

  if (!y2_boundary_condition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y2-boundary-condition",
      "");
  }

  if (!z1_boundary_condition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z1-boundary-condition",
      "");
  }

  if (!z2_boundary_condition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z2-boundary-condition",
      "");
  }

  if (!brownian_motion_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "brownian-motion",
      "");
  }

  if (!initial_temperature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial-temperature",
      "");
  }

  if (!n_thermostat_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n-thermostat",
      "");
  }

  if (!target_temperature_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "target-temperature",
      "");
  }

  if (!temperature_difference_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "temperature-difference",
      "");
  }

  if (!gravitation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "gravitation",
      "");
  }

  if (!r0_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r0",
      "");
  }

  if (!k_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "k",
      "");
  }

  if (!fz_up_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "fz-up",
      "");
  }

  if (!parallelisation_method_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parallelisation-method",
      "");
  }

  if (!force_calculation_method_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "force-calculation-method",
      "");
  }

  if (!rl_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rl",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

settingsType* settingsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class settingsType (*this, f, c);
}

settingsType& settingsType::
operator= (const settingsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->delta_t_ = x.delta_t_;
    this->end_time_ = x.end_time_;
    this->factor_ = x.factor_;
    this->domain_size_ = x.domain_size_;
    this->rcutoff_ = x.rcutoff_;
    this->x1_boundary_condition_ = x.x1_boundary_condition_;
    this->x2_boundary_condition_ = x.x2_boundary_condition_;
    this->y1_boundary_condition_ = x.y1_boundary_condition_;
    this->y2_boundary_condition_ = x.y2_boundary_condition_;
    this->z1_boundary_condition_ = x.z1_boundary_condition_;
    this->z2_boundary_condition_ = x.z2_boundary_condition_;
    this->brownian_motion_ = x.brownian_motion_;
    this->initial_temperature_ = x.initial_temperature_;
    this->n_thermostat_ = x.n_thermostat_;
    this->target_temperature_ = x.target_temperature_;
    this->temperature_difference_ = x.temperature_difference_;
    this->gravitation_ = x.gravitation_;
    this->r0_ = x.r0_;
    this->k_ = x.k_;
    this->fz_up_ = x.fz_up_;
    this->parallelisation_method_ = x.parallelisation_method_;
    this->force_calculation_method_ = x.force_calculation_method_;
    this->rl_ = x.rl_;
    this->id_ = x.id_;
  }

  return *this;
}

settingsType::
~settingsType ()
{
}

// write_checkpointType
//

write_checkpointType::
write_checkpointType ()
: ::xml_schema::string (),
  bol_ (this)
{
}

write_checkpointType::
write_checkpointType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

write_checkpointType::
write_checkpointType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

write_checkpointType::
write_checkpointType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

write_checkpointType::
write_checkpointType (const write_checkpointType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  bol_ (x.bol_, f, this)
{
}

write_checkpointType::
write_checkpointType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  bol_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void write_checkpointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bol" && n.namespace_ ().empty ())
    {
      this->bol_.set (bol_traits::create (i, f, this));
      continue;
    }
  }
}

write_checkpointType* write_checkpointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class write_checkpointType (*this, f, c);
}

write_checkpointType& write_checkpointType::
operator= (const write_checkpointType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->bol_ = x.bol_;
  }

  return *this;
}

write_checkpointType::
~write_checkpointType ()
{
}

// read_checkpointType
//

read_checkpointType::
read_checkpointType ()
: ::xml_schema::string (),
  bol_ (this)
{
}

read_checkpointType::
read_checkpointType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

read_checkpointType::
read_checkpointType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

read_checkpointType::
read_checkpointType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

read_checkpointType::
read_checkpointType (const read_checkpointType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  bol_ (x.bol_, f, this)
{
}

read_checkpointType::
read_checkpointType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  bol_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void read_checkpointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bol" && n.namespace_ ().empty ())
    {
      this->bol_.set (bol_traits::create (i, f, this));
      continue;
    }
  }
}

read_checkpointType* read_checkpointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class read_checkpointType (*this, f, c);
}

read_checkpointType& read_checkpointType::
operator= (const read_checkpointType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->bol_ = x.bol_;
  }

  return *this;
}

read_checkpointType::
~read_checkpointType ()
{
}

// write_checkpoint_timeType
//

write_checkpoint_timeType::
write_checkpoint_timeType ()
: ::xml_schema::string (),
  t_ (this)
{
}

write_checkpoint_timeType::
write_checkpoint_timeType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

write_checkpoint_timeType::
write_checkpoint_timeType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

write_checkpoint_timeType::
write_checkpoint_timeType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  t_ (this)
{
}

write_checkpoint_timeType::
write_checkpoint_timeType (const write_checkpoint_timeType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  t_ (x.t_, f, this)
{
}

write_checkpoint_timeType::
write_checkpoint_timeType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  t_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void write_checkpoint_timeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "t" && n.namespace_ ().empty ())
    {
      this->t_.set (t_traits::create (i, f, this));
      continue;
    }
  }
}

write_checkpoint_timeType* write_checkpoint_timeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class write_checkpoint_timeType (*this, f, c);
}

write_checkpoint_timeType& write_checkpoint_timeType::
operator= (const write_checkpoint_timeType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->t_ = x.t_;
  }

  return *this;
}

write_checkpoint_timeType::
~write_checkpoint_timeType ()
{
}

// checkpointType
//

checkpointType::
checkpointType (const write_checkpoint_type& write_checkpoint,
                const read_checkpoint_type& read_checkpoint,
                const write_checkpoint_time_type& write_checkpoint_time)
: ::xml_schema::type (),
  write_checkpoint_ (write_checkpoint, this),
  read_checkpoint_ (read_checkpoint, this),
  write_checkpoint_time_ (write_checkpoint_time, this),
  id_ (this)
{
}

checkpointType::
checkpointType (::std::unique_ptr< write_checkpoint_type > write_checkpoint,
                ::std::unique_ptr< read_checkpoint_type > read_checkpoint,
                ::std::unique_ptr< write_checkpoint_time_type > write_checkpoint_time)
: ::xml_schema::type (),
  write_checkpoint_ (std::move (write_checkpoint), this),
  read_checkpoint_ (std::move (read_checkpoint), this),
  write_checkpoint_time_ (std::move (write_checkpoint_time), this),
  id_ (this)
{
}

checkpointType::
checkpointType (const checkpointType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  write_checkpoint_ (x.write_checkpoint_, f, this),
  read_checkpoint_ (x.read_checkpoint_, f, this),
  write_checkpoint_time_ (x.write_checkpoint_time_, f, this),
  id_ (x.id_, f, this)
{
}

checkpointType::
checkpointType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  write_checkpoint_ (this),
  read_checkpoint_ (this),
  write_checkpoint_time_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void checkpointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // write-checkpoint
    //
    if (n.name () == "write-checkpoint" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< write_checkpoint_type > r (
        write_checkpoint_traits::create (i, f, this));

      if (!write_checkpoint_.present ())
      {
        this->write_checkpoint_.set (::std::move (r));
        continue;
      }
    }

    // read-checkpoint
    //
    if (n.name () == "read-checkpoint" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< read_checkpoint_type > r (
        read_checkpoint_traits::create (i, f, this));

      if (!read_checkpoint_.present ())
      {
        this->read_checkpoint_.set (::std::move (r));
        continue;
      }
    }

    // write-checkpoint-time
    //
    if (n.name () == "write-checkpoint-time" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< write_checkpoint_time_type > r (
        write_checkpoint_time_traits::create (i, f, this));

      if (!write_checkpoint_time_.present ())
      {
        this->write_checkpoint_time_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!write_checkpoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "write-checkpoint",
      "");
  }

  if (!read_checkpoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "read-checkpoint",
      "");
  }

  if (!write_checkpoint_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "write-checkpoint-time",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

checkpointType* checkpointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class checkpointType (*this, f, c);
}

checkpointType& checkpointType::
operator= (const checkpointType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->write_checkpoint_ = x.write_checkpoint_;
    this->read_checkpoint_ = x.read_checkpoint_;
    this->write_checkpoint_time_ = x.write_checkpoint_time_;
    this->id_ = x.id_;
  }

  return *this;
}

checkpointType::
~checkpointType ()
{
}

// typeType
//

typeType::
typeType ()
: ::xml_schema::string (),
  val_ (this)
{
}

typeType::
typeType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

typeType::
typeType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

typeType::
typeType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

typeType::
typeType (const typeType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

typeType::
typeType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void typeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

typeType* typeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class typeType (*this, f, c);
}

typeType& typeType::
operator= (const typeType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

typeType::
~typeType ()
{
}

// epsilonType
//

epsilonType::
epsilonType ()
: ::xml_schema::string (),
  val_ (this)
{
}

epsilonType::
epsilonType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

epsilonType::
epsilonType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

epsilonType::
epsilonType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

epsilonType::
epsilonType (const epsilonType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

epsilonType::
epsilonType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void epsilonType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

epsilonType* epsilonType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class epsilonType (*this, f, c);
}

epsilonType& epsilonType::
operator= (const epsilonType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

epsilonType::
~epsilonType ()
{
}

// sigmaType
//

sigmaType::
sigmaType ()
: ::xml_schema::string (),
  val_ (this)
{
}

sigmaType::
sigmaType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

sigmaType::
sigmaType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

sigmaType::
sigmaType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

sigmaType::
sigmaType (const sigmaType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

sigmaType::
sigmaType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void sigmaType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

sigmaType* sigmaType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sigmaType (*this, f, c);
}

sigmaType& sigmaType::
operator= (const sigmaType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

sigmaType::
~sigmaType ()
{
}

// centreType
//

centreType::
centreType ()
: ::xml_schema::string (),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

centreType::
centreType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

centreType::
centreType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

centreType::
centreType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

centreType::
centreType (const centreType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

centreType::
centreType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void centreType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }
}

centreType* centreType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class centreType (*this, f, c);
}

centreType& centreType::
operator= (const centreType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

centreType::
~centreType ()
{
}

// radiusType
//

radiusType::
radiusType ()
: ::xml_schema::string (),
  val_ (this)
{
}

radiusType::
radiusType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

radiusType::
radiusType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

radiusType::
radiusType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

radiusType::
radiusType (const radiusType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

radiusType::
radiusType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void radiusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

radiusType* radiusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class radiusType (*this, f, c);
}

radiusType& radiusType::
operator= (const radiusType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

radiusType::
~radiusType ()
{
}

// velocityType
//

velocityType::
velocityType ()
: ::xml_schema::string (),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

velocityType::
velocityType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

velocityType::
velocityType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

velocityType::
velocityType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

velocityType::
velocityType (const velocityType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

velocityType::
velocityType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void velocityType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }
}

velocityType* velocityType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class velocityType (*this, f, c);
}

velocityType& velocityType::
operator= (const velocityType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

velocityType::
~velocityType ()
{
}

// massType
//

massType::
massType ()
: ::xml_schema::string (),
  val_ (this)
{
}

massType::
massType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

massType::
massType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

massType::
massType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

massType::
massType (const massType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

massType::
massType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void massType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

massType* massType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class massType (*this, f, c);
}

massType& massType::
operator= (const massType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

massType::
~massType ()
{
}

// hType
//

hType::
hType ()
: ::xml_schema::string (),
  val_ (this)
{
}

hType::
hType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

hType::
hType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

hType::
hType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  val_ (this)
{
}

hType::
hType (const hType& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  val_ (x.val_, f, this)
{
}

hType::
hType (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  val_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void hType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "val" && n.namespace_ ().empty ())
    {
      this->val_.set (val_traits::create (i, f, this));
      continue;
    }
  }
}

hType* hType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class hType (*this, f, c);
}

hType& hType::
operator= (const hType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->val_ = x.val_;
  }

  return *this;
}

hType::
~hType ()
{
}

// sphereType
//

sphereType::
sphereType (const type_type& type,
            const epsilon_type& epsilon,
            const sigma_type& sigma,
            const centre_type& centre,
            const radius_type& radius,
            const velocity_type& velocity,
            const mass_type& mass,
            const h_type& h)
: ::xml_schema::type (),
  type_ (type, this),
  epsilon_ (epsilon, this),
  sigma_ (sigma, this),
  centre_ (centre, this),
  radius_ (radius, this),
  velocity_ (velocity, this),
  mass_ (mass, this),
  h_ (h, this),
  id_ (this)
{
}

sphereType::
sphereType (::std::unique_ptr< type_type > type,
            ::std::unique_ptr< epsilon_type > epsilon,
            ::std::unique_ptr< sigma_type > sigma,
            ::std::unique_ptr< centre_type > centre,
            ::std::unique_ptr< radius_type > radius,
            ::std::unique_ptr< velocity_type > velocity,
            ::std::unique_ptr< mass_type > mass,
            ::std::unique_ptr< h_type > h)
: ::xml_schema::type (),
  type_ (std::move (type), this),
  epsilon_ (std::move (epsilon), this),
  sigma_ (std::move (sigma), this),
  centre_ (std::move (centre), this),
  radius_ (std::move (radius), this),
  velocity_ (std::move (velocity), this),
  mass_ (std::move (mass), this),
  h_ (std::move (h), this),
  id_ (this)
{
}

sphereType::
sphereType (const sphereType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this),
  centre_ (x.centre_, f, this),
  radius_ (x.radius_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this),
  h_ (x.h_, f, this),
  id_ (x.id_, f, this)
{
}

sphereType::
sphereType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  epsilon_ (this),
  sigma_ (this),
  centre_ (this),
  radius_ (this),
  velocity_ (this),
  mass_ (this),
  h_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void sphereType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< epsilon_type > r (
        epsilon_traits::create (i, f, this));

      if (!epsilon_.present ())
      {
        this->epsilon_.set (::std::move (r));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sigma_type > r (
        sigma_traits::create (i, f, this));

      if (!sigma_.present ())
      {
        this->sigma_.set (::std::move (r));
        continue;
      }
    }

    // centre
    //
    if (n.name () == "centre" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< centre_type > r (
        centre_traits::create (i, f, this));

      if (!centre_.present ())
      {
        this->centre_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!mass_.present ())
      {
        this->mass_.set (::std::move (r));
        continue;
      }
    }

    // h
    //
    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< h_type > r (
        h_traits::create (i, f, this));

      if (!h_.present ())
      {
        this->h_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!centre_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "centre",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "h",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

sphereType* sphereType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphereType (*this, f, c);
}

sphereType& sphereType::
operator= (const sphereType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->centre_ = x.centre_;
    this->radius_ = x.radius_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
    this->h_ = x.h_;
    this->id_ = x.id_;
  }

  return *this;
}

sphereType::
~sphereType ()
{
}

// right_top_pointType
//

right_top_pointType::
right_top_pointType ()
: ::xml_schema::string (),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

right_top_pointType::
right_top_pointType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

right_top_pointType::
right_top_pointType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

right_top_pointType::
right_top_pointType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

right_top_pointType::
right_top_pointType (const right_top_pointType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

right_top_pointType::
right_top_pointType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void right_top_pointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }
}

right_top_pointType* right_top_pointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class right_top_pointType (*this, f, c);
}

right_top_pointType& right_top_pointType::
operator= (const right_top_pointType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

right_top_pointType::
~right_top_pointType ()
{
}

// side_lengthsType
//

side_lengthsType::
side_lengthsType ()
: ::xml_schema::string (),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

side_lengthsType::
side_lengthsType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

side_lengthsType::
side_lengthsType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

side_lengthsType::
side_lengthsType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  x_ (this),
  y_ (this),
  z_ (this)
{
}

side_lengthsType::
side_lengthsType (const side_lengthsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

side_lengthsType::
side_lengthsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void side_lengthsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }
}

side_lengthsType* side_lengthsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class side_lengthsType (*this, f, c);
}

side_lengthsType& side_lengthsType::
operator= (const side_lengthsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

side_lengthsType::
~side_lengthsType ()
{
}

// membraneType
//

membraneType::
membraneType ()
: ::xml_schema::string (),
  bol_ (this)
{
}

membraneType::
membraneType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

membraneType::
membraneType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

membraneType::
membraneType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  bol_ (this)
{
}

membraneType::
membraneType (const membraneType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  bol_ (x.bol_, f, this)
{
}

membraneType::
membraneType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  bol_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void membraneType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bol" && n.namespace_ ().empty ())
    {
      this->bol_.set (bol_traits::create (i, f, this));
      continue;
    }
  }
}

membraneType* membraneType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class membraneType (*this, f, c);
}

membraneType& membraneType::
operator= (const membraneType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->bol_ = x.bol_;
  }

  return *this;
}

membraneType::
~membraneType ()
{
}

// cuboidType
//

cuboidType::
cuboidType (const type_type& type,
            const epsilon_type& epsilon,
            const sigma_type& sigma,
            const right_top_point_type& right_top_point,
            const side_lengths_type& side_lengths,
            const velocity_type& velocity,
            const mass_type& mass,
            const h_type& h,
            const membrane_type& membrane)
: ::xml_schema::type (),
  type_ (type, this),
  epsilon_ (epsilon, this),
  sigma_ (sigma, this),
  right_top_point_ (right_top_point, this),
  side_lengths_ (side_lengths, this),
  velocity_ (velocity, this),
  mass_ (mass, this),
  h_ (h, this),
  membrane_ (membrane, this),
  id_ (this)
{
}

cuboidType::
cuboidType (::std::unique_ptr< type_type > type,
            ::std::unique_ptr< epsilon_type > epsilon,
            ::std::unique_ptr< sigma_type > sigma,
            ::std::unique_ptr< right_top_point_type > right_top_point,
            ::std::unique_ptr< side_lengths_type > side_lengths,
            ::std::unique_ptr< velocity_type > velocity,
            ::std::unique_ptr< mass_type > mass,
            ::std::unique_ptr< h_type > h,
            ::std::unique_ptr< membrane_type > membrane)
: ::xml_schema::type (),
  type_ (std::move (type), this),
  epsilon_ (std::move (epsilon), this),
  sigma_ (std::move (sigma), this),
  right_top_point_ (std::move (right_top_point), this),
  side_lengths_ (std::move (side_lengths), this),
  velocity_ (std::move (velocity), this),
  mass_ (std::move (mass), this),
  h_ (std::move (h), this),
  membrane_ (std::move (membrane), this),
  id_ (this)
{
}

cuboidType::
cuboidType (const cuboidType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this),
  right_top_point_ (x.right_top_point_, f, this),
  side_lengths_ (x.side_lengths_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this),
  h_ (x.h_, f, this),
  membrane_ (x.membrane_, f, this),
  id_ (x.id_, f, this)
{
}

cuboidType::
cuboidType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  epsilon_ (this),
  sigma_ (this),
  right_top_point_ (this),
  side_lengths_ (this),
  velocity_ (this),
  mass_ (this),
  h_ (this),
  membrane_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void cuboidType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< epsilon_type > r (
        epsilon_traits::create (i, f, this));

      if (!epsilon_.present ())
      {
        this->epsilon_.set (::std::move (r));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sigma_type > r (
        sigma_traits::create (i, f, this));

      if (!sigma_.present ())
      {
        this->sigma_.set (::std::move (r));
        continue;
      }
    }

    // right-top-point
    //
    if (n.name () == "right-top-point" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_top_point_type > r (
        right_top_point_traits::create (i, f, this));

      if (!right_top_point_.present ())
      {
        this->right_top_point_.set (::std::move (r));
        continue;
      }
    }

    // side-lengths
    //
    if (n.name () == "side-lengths" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< side_lengths_type > r (
        side_lengths_traits::create (i, f, this));

      if (!side_lengths_.present ())
      {
        this->side_lengths_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!mass_.present ())
      {
        this->mass_.set (::std::move (r));
        continue;
      }
    }

    // h
    //
    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< h_type > r (
        h_traits::create (i, f, this));

      if (!h_.present ())
      {
        this->h_.set (::std::move (r));
        continue;
      }
    }

    // membrane
    //
    if (n.name () == "membrane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< membrane_type > r (
        membrane_traits::create (i, f, this));

      if (!membrane_.present ())
      {
        this->membrane_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!right_top_point_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right-top-point",
      "");
  }

  if (!side_lengths_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "side-lengths",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "h",
      "");
  }

  if (!membrane_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "membrane",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }
}

cuboidType* cuboidType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboidType (*this, f, c);
}

cuboidType& cuboidType::
operator= (const cuboidType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->right_top_point_ = x.right_top_point_;
    this->side_lengths_ = x.side_lengths_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
    this->h_ = x.h_;
    this->membrane_ = x.membrane_;
    this->id_ = x.id_;
  }

  return *this;
}

cuboidType::
~cuboidType ()
{
}

// shapesType
//

shapesType::
shapesType (const settings_type& settings)
: ::xml_schema::type (),
  settings_ (settings, this),
  checkpoint_ (this),
  sphere_ (this),
  cuboid_ (this)
{
}

shapesType::
shapesType (::std::unique_ptr< settings_type > settings)
: ::xml_schema::type (),
  settings_ (std::move (settings), this),
  checkpoint_ (this),
  sphere_ (this),
  cuboid_ (this)
{
}

shapesType::
shapesType (const shapesType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  settings_ (x.settings_, f, this),
  checkpoint_ (x.checkpoint_, f, this),
  sphere_ (x.sphere_, f, this),
  cuboid_ (x.cuboid_, f, this)
{
}

shapesType::
shapesType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  settings_ (this),
  checkpoint_ (this),
  sphere_ (this),
  cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void shapesType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // settings
    //
    if (n.name () == "settings" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< settings_type > r (
        settings_traits::create (i, f, this));

      if (!settings_.present ())
      {
        this->settings_.set (::std::move (r));
        continue;
      }
    }

    // checkpoint
    //
    if (n.name () == "checkpoint" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< checkpoint_type > r (
        checkpoint_traits::create (i, f, this));

      if (!this->checkpoint_)
      {
        this->checkpoint_.set (::std::move (r));
        continue;
      }
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      this->sphere_.push_back (::std::move (r));
      continue;
    }

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!settings_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "settings",
      "");
  }
}

shapesType* shapesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class shapesType (*this, f, c);
}

shapesType& shapesType::
operator= (const shapesType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->settings_ = x.settings_;
    this->checkpoint_ = x.checkpoint_;
    this->sphere_ = x.sphere_;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

shapesType::
~shapesType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::shapesType >
shapes (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::shapesType > (
    ::shapes (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::shapesType >
shapes (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::shapesType > (
    ::shapes (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::shapesType >
shapes (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::shapesType > (
    ::shapes (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::shapesType >
shapes (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::shapes (isrc, f, p);
}

::std::unique_ptr< ::shapesType >
shapes (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::shapes (isrc, h, f, p);
}

::std::unique_ptr< ::shapesType >
shapes (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::shapes (isrc, h, f, p);
}

::std::unique_ptr< ::shapesType >
shapes (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::shapes (isrc, f, p);
}

::std::unique_ptr< ::shapesType >
shapes (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::shapes (isrc, h, f, p);
}

::std::unique_ptr< ::shapesType >
shapes (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::shapes (isrc, h, f, p);
}

::std::unique_ptr< ::shapesType >
shapes (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::shapesType > (
    ::shapes (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::shapesType >
shapes (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::shapesType > (
    ::shapes (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::shapesType >
shapes (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::shapesType > (
    ::shapes (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::shapesType >
shapes (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::shapesType > (
      ::shapes (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "shapes" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::shapesType > r (
      ::xsd::cxx::tree::traits< ::shapesType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "shapes",
    "");
}

::std::unique_ptr< ::shapesType >
shapes (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "shapes" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::shapesType > r (
      ::xsd::cxx::tree::traits< ::shapesType, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "shapes",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

